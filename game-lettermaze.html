<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lettermaze - DATOV</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            padding: 1.5rem;
            background: rgba(21, 23, 37, 0.5);
            border-radius: var(--radius-md);
            border: 1px solid rgba(255, 255, 255, 0.05);
            max-width: 900px;
            margin: 0 auto;
        }

        .game-layout {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .grid-container {
            background: #222;
            padding: 10px;
            border-radius: 8px;
            user-select: none;
            touch-action: none;
        }

        .grid {
            display: grid;
            gap: 2px;
        }

        .cell {
            width: 35px;
            height: 35px;
            background: #333;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .cell:hover {
            background: #444;
        }

        .cell.selected {
            background: var(--primary);
            color: #000;
        }

        .cell.found {
            background: #4caf50;
            color: #fff;
            animation: pulse 0.5s;
        }

        .word-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 200px;
        }

        .word-item {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 1.1rem;
            transition: opacity 0.3s;
        }

        .word-item.found {
            text-decoration: line-through;
            opacity: 0.5;
            background: rgba(76, 175, 80, 0.2);
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        @media (max-width: 600px) {
            .cell {
                width: 28px;
                height: 28px;
                font-size: 1rem;
            }
        }
    </style>
</head>

<body>

    <header class="header">
        <div class="container flex flex-between">
            <a href="index.html" class="logo">DATOV</a>
            <nav>
                <ul class="nav-links">
                    <li><a href="index.html#games">Back to Games</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <section class="section" style="padding-top: 8rem;">
        <div class="container">
            <div class="game-container">
                <div class="game-header">
                    <h2>Lettermaze</h2>
                    <p>Find all the hidden words in the grid!</p>
                </div>

                <div class="game-layout">
                    <div class="grid-container" id="gridContainer">
                        <!-- Grid generated by JS -->
                    </div>

                    <div class="word-list" id="wordList">
                        <!-- Words generated by JS -->
                    </div>
                </div>

                <div class="controls">
                    <button id="newGameBtn" class="btn btn-primary">New Game</button>
                    <div id="timer" style="font-size: 1.2rem; font-weight: bold;">00:00</div>
                </div>
            </div>
        </div>
    </section>

    <script src="game-interface.js"></script>
    <script>
        const gridContainer = document.getElementById('gridContainer');
        const wordListEl = document.getElementById('wordList');
        const newGameBtn = document.getElementById('newGameBtn');
        const timerEl = document.getElementById('timer');

        const GRID_SIZE = 12;
        const WORD_POOL = [
            'JAVASCRIPT', 'HTML', 'CSS', 'PYTHON', 'CODING', 'BROWSER', 'INTERNET',
            'GAMING', 'PIXEL', 'VECTOR', 'LOGIC', 'PUZZLE', 'MEMORY', 'SPEED',
            'REACT', 'NODE', 'SERVER', 'CLIENT', 'DATA', 'CLOUD', 'CYBER',
            'NEON', 'ARCADE', 'RETRO', 'FUTURE', 'SPACE', 'ROBOT', 'LASER'
        ];

        let grid = [];
        let words = [];
        let foundWords = [];
        let isSelecting = false;
        let selectionStart = null;
        let selectedCells = [];
        let timerInterval;
        let startTime;

        GameInterface.init({
            name: 'Lettermaze',
            description: 'Classic word search puzzle. Find hidden words in the grid.',
            url: 'game-lettermaze.html',
            howToPlay: [
                'Find the words listed on the right.',
                'Click and drag to select letters.',
                'Words can be horizontal, vertical, or diagonal.',
                'Find all words to win!'
            ]
        });

        newGameBtn.addEventListener('click', startNewGame);

        function startNewGame() {
            clearInterval(timerInterval);
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);

            words = selectRandomWords(8);
            foundWords = [];
            generateGrid();
            renderGrid();
            renderWordList();
        }

        function selectRandomWords(count) {
            const shuffled = [...WORD_POOL].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        function generateGrid() {
            // Initialize empty grid
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(''));

            // Place words
            for (const word of words) {
                placeWord(word);
            }

            // Fill empty cells
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = letters[Math.floor(Math.random() * letters.length)];
                    }
                }
            }
        }

        function placeWord(word) {
            let placed = false;
            let attempts = 0;
            while (!placed && attempts < 100) {
                const dir = Math.floor(Math.random() * 3); // 0: horiz, 1: vert, 2: diag
                const r = Math.floor(Math.random() * GRID_SIZE);
                const c = Math.floor(Math.random() * GRID_SIZE);

                if (canPlace(word, r, c, dir)) {
                    for (let i = 0; i < word.length; i++) {
                        if (dir === 0) grid[r][c + i] = word[i];
                        else if (dir === 1) grid[r + i][c] = word[i];
                        else grid[r + i][c + i] = word[i];
                    }
                    placed = true;
                }
                attempts++;
            }
        }

        function canPlace(word, r, c, dir) {
            if (dir === 0 && c + word.length > GRID_SIZE) return false;
            if (dir === 1 && r + word.length > GRID_SIZE) return false;
            if (dir === 2 && (r + word.length > GRID_SIZE || c + word.length > GRID_SIZE)) return false;

            for (let i = 0; i < word.length; i++) {
                let cell;
                if (dir === 0) cell = grid[r][c + i];
                else if (dir === 1) cell = grid[r + i][c];
                else cell = grid[r + i][c + i];

                if (cell !== '' && cell !== word[i]) return false;
            }
            return true;
        }

        function renderGrid() {
            gridContainer.innerHTML = '';
            gridContainer.style.display = 'grid';
            gridContainer.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = grid[r][c];
                    cell.dataset.r = r;
                    cell.dataset.c = c;

                    cell.addEventListener('mousedown', handleMouseDown);
                    cell.addEventListener('mouseenter', handleMouseEnter);
                    cell.addEventListener('mouseup', handleMouseUp);
                    // Touch support
                    cell.addEventListener('touchstart', handleTouchStart, { passive: false });
                    cell.addEventListener('touchmove', handleTouchMove, { passive: false });
                    cell.addEventListener('touchend', handleMouseUp);

                    gridContainer.appendChild(cell);
                }
            }
        }

        function renderWordList() {
            wordListEl.innerHTML = '';
            words.forEach(word => {
                const div = document.createElement('div');
                div.className = `word-item ${foundWords.includes(word) ? 'found' : ''}`;
                div.textContent = word;
                wordListEl.appendChild(div);
            });
        }

        function handleMouseDown(e) {
            isSelecting = true;
            selectionStart = {
                r: parseInt(e.target.dataset.r),
                c: parseInt(e.target.dataset.c)
            };
            updateSelection(e.target);
        }

        function handleMouseEnter(e) {
            if (isSelecting) {
                updateSelection(e.target);
            }
        }

        function handleMouseUp() {
            if (!isSelecting) return;
            isSelecting = false;
            checkSelection();
            clearSelection();
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            if (element && element.classList.contains('cell')) {
                handleMouseDown({ target: element });
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!isSelecting) return;
            const touch = e.touches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            if (element && element.classList.contains('cell')) {
                updateSelection(element);
            }
        }

        function updateSelection(endCell) {
            clearSelection();
            const endR = parseInt(endCell.dataset.r);
            const endC = parseInt(endCell.dataset.c);

            // Calculate direction
            const dr = endR - selectionStart.r;
            const dc = endC - selectionStart.c;

            // Only allow horizontal, vertical, or diagonal
            if (dr === 0 || dc === 0 || Math.abs(dr) === Math.abs(dc)) {
                const steps = Math.max(Math.abs(dr), Math.abs(dc));
                const stepR = dr === 0 ? 0 : dr / Math.abs(dr);
                const stepC = dc === 0 ? 0 : dc / Math.abs(dc);

                for (let i = 0; i <= steps; i++) {
                    const r = selectionStart.r + i * stepR;
                    const c = selectionStart.c + i * stepC;
                    const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
                    if (cell) {
                        cell.classList.add('selected');
                        selectedCells.push(cell);
                    }
                }
            }
        }

        function clearSelection() {
            selectedCells.forEach(cell => cell.classList.remove('selected'));
            selectedCells = [];
        }

        function checkSelection() {
            const word = selectedCells.map(cell => cell.textContent).join('');
            const reversedWord = word.split('').reverse().join('');

            if (words.includes(word) && !foundWords.includes(word)) {
                markFound(word);
            } else if (words.includes(reversedWord) && !foundWords.includes(reversedWord)) {
                markFound(reversedWord);
            }
        }

        function markFound(word) {
            foundWords.push(word);
            selectedCells.forEach(cell => {
                cell.classList.add('found');
                // Keep found cells highlighted but distinct from selection
                cell.style.background = '#4caf50';
            });
            renderWordList();

            if (foundWords.length === words.length) {
                clearInterval(timerInterval);
                setTimeout(() => {
                    GameInterface.showGameOver({
                        text: 'All Words Found!',
                        score: timerEl.textContent,
                        level: 'Standard'
                    });
                }, 500);
            }
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const m = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const s = (elapsed % 60).toString().padStart(2, '0');
            timerEl.textContent = `${m}:${s}`;
        }

        startNewGame();

    </script>
</body>

</html>