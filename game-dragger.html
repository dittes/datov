<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dragger - DATOV</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
            padding: 2rem;
            background: rgba(21, 23, 37, 0.5);
            border-radius: var(--radius-md);
            border: 1px solid rgba(255, 255, 255, 0.05);
            max-width: 800px;
            margin: 0 auto;
        }

        .level-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .puzzle-area {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .grid-board {
            display: grid;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary);
            border-radius: var(--radius-sm);
            position: relative;
        }

        .grid-cell {
            width: 50px;
            height: 50px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-sizing: border-box;
        }

        .grid-cell.filled {
            background: rgba(0, 243, 255, 0.2);
        }

        .pieces-container {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-sm);
            min-height: 100px;
            align-items: center;
            justify-content: center;
        }

        .piece {
            cursor: grab;
            display: grid;
            gap: 1px;
            transition: transform 0.1s;
            touch-action: none;
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.05);
        }

        .block {
            width: 50px;
            height: 50px;
            background: var(--secondary);
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .piece.placed .block {
            background: var(--primary);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
        }

        .controls {
            display: flex;
            gap: 1rem;
        }

        /* Mobile Adjustments */
        @media (max-width: 600px) {

            .grid-cell,
            .block {
                width: 35px;
                height: 35px;
            }
        }
    </style>
</head>

<body>

    <header class="header">
        <div class="container flex flex-between">
            <a href="index.html" class="logo">DATOV</a>
            <nav>
                <ul class="nav-links">
                    <li><a href="index.html#games">Back to Games</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <section class="section" style="padding-top: 8rem;">
        <div class="container">
            <div class="game-container">
                <div class="level-info">
                    <span id="levelDisplay">Level: 1</span>
                    <span id="scoreDisplay">Score: 0</span>
                </div>

                <div class="puzzle-area">
                    <div id="gridBoard" class="grid-board">
                        <!-- Grid generated by JS -->
                    </div>
                </div>

                <div id="piecesContainer" class="pieces-container">
                    <!-- Pieces generated by JS -->
                </div>

                <div class="controls">
                    <button id="resetBtn" class="btn btn-primary">Reset Level</button>
                    <button id="nextBtn" class="btn btn-primary" style="display: none;">Next Level</button>
                </div>
            </div>
        </div>
    </section>

    <script src="game-interface.js"></script>
    <script>
        const GRID_SIZE = 6;
        const CELL_SIZE = 50; // Matches CSS
        let currentLevel = 1;
        let score = 0;
        let grid = [];
        let pieces = [];

        const levels = [
            {
                target: [[0, 0], [0, 1], [1, 0], [1, 1]], // 2x2 square
                pieces: [
                    { shape: [[0, 0], [0, 1]], color: '#ff00ff' }, // 1x2
                    { shape: [[0, 0], [0, 1]], color: '#ff00ff' }  // 1x2
                ]
            },
            {
                target: [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2]], // 2x3 rect
                pieces: [
                    { shape: [[0, 0], [0, 1], [0, 2]], color: '#ff00ff' }, // 1x3
                    { shape: [[0, 0], [0, 1], [0, 2]], color: '#ff00ff' }  // 1x3
                ]
            },
            {
                target: [[0, 0], [0, 1], [1, 1], [2, 1], [2, 2]], // Z shape ish
                pieces: [
                    { shape: [[0, 0], [0, 1]], color: '#ff00ff' },
                    { shape: [[0, 0], [1, 0]], color: '#ff00ff' },
                    { shape: [[0, 0]], color: '#ff00ff' }
                ]
            }
        ];

        // Dynamic difficulty scaling generator (simple version)
        function generateLevel(levelNum) {
            if (levelNum <= levels.length) return levels[levelNum - 1];

            // Procedural generation placeholder
            return levels[levelNum % levels.length];
        }

        function initGame() {
            GameInterface.init({
                name: 'Dragger',
                description: 'Drag and drop puzzle game. Fit the pieces into the grid.',
                howToPlay: [
                    'Drag the colored pieces from the bottom.',
                    'Drop them into the grid to match the target shape.',
                    'Complete the level to advance.',
                    'Don\'t worry about mistakes, you can reset the level.'
                ]
            });

            loadState();
            setupLevel(currentLevel);

            document.getElementById('resetBtn').addEventListener('click', () => setupLevel(currentLevel));
            document.getElementById('nextBtn').addEventListener('click', () => {
                currentLevel++;
                setupLevel(currentLevel);
                document.getElementById('nextBtn').style.display = 'none';
            });
        }

        function setupLevel(levelNum) {
            const levelData = generateLevel(levelNum);
            const board = document.getElementById('gridBoard');
            const piecesCont = document.getElementById('piecesContainer');

            document.getElementById('levelDisplay').textContent = `Level: ${levelNum}`;

            // Setup Grid
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
            board.style.gridTemplateRows = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;

            // Create empty grid cells
            // For simplicity, we just make a 6x6 grid and mark target area
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));

            // Mark target cells visually
            // In a real implementation, we'd center the target shape
            // For now, we just use top-left for simplicity

            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.index = i;
                board.appendChild(cell);
            }

            // Setup Pieces
            piecesCont.innerHTML = '';
            levelData.pieces.forEach((pData, idx) => {
                createPiece(pData, idx);
            });
        }

        function createPiece(pieceData, id) {
            const piece = document.createElement('div');
            piece.className = 'piece';
            piece.draggable = true;
            piece.id = `piece-${id}`;

            // Calculate grid dimensions for the piece
            let maxX = 0, maxY = 0;
            pieceData.shape.forEach(([x, y]) => {
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            });

            piece.style.gridTemplateColumns = `repeat(${maxX + 1}, ${CELL_SIZE}px)`;
            piece.style.gridTemplateRows = `repeat(${maxY + 1}, ${CELL_SIZE}px)`;

            pieceData.shape.forEach(([x, y]) => {
                const block = document.createElement('div');
                block.className = 'block';
                block.style.gridColumn = x + 1;
                block.style.gridRow = y + 1;
                piece.appendChild(block);
            });

            // Drag Events
            piece.addEventListener('dragstart', handleDragStart);
            piece.addEventListener('dragend', handleDragEnd);

            // Touch Events shim
            piece.addEventListener('touchstart', handleTouchStart, { passive: false });
            piece.addEventListener('touchmove', handleTouchMove, { passive: false });
            piece.addEventListener('touchend', handleTouchEnd);

            document.getElementById('piecesContainer').appendChild(piece);
        }

        let draggedPiece = null;

        function handleDragStart(e) {
            draggedPiece = this;
            setTimeout(() => this.style.opacity = '0.5', 0);
        }

        function handleDragEnd(e) {
            this.style.opacity = '1';
            checkDrop(e.clientX, e.clientY);
            draggedPiece = null;
        }

        // Touch handling
        let touchOffsetX, touchOffsetY;

        function handleTouchStart(e) {
            e.preventDefault();
            draggedPiece = this;
            const touch = e.touches[0];
            const rect = this.getBoundingClientRect();
            touchOffsetX = touch.clientX - rect.left;
            touchOffsetY = touch.clientY - rect.top;

            this.style.position = 'fixed';
            this.style.zIndex = 1000;
            this.style.opacity = '0.8';
            moveAt(touch.clientX, touch.clientY);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!draggedPiece) return;
            const touch = e.touches[0];
            moveAt(touch.clientX, touch.clientY);
        }

        function moveAt(pageX, pageY) {
            draggedPiece.style.left = pageX - touchOffsetX + 'px';
            draggedPiece.style.top = pageY - touchOffsetY + 'px';
        }

        function handleTouchEnd(e) {
            if (!draggedPiece) return;
            const touch = e.changedTouches[0];

            draggedPiece.style.position = '';
            draggedPiece.style.zIndex = '';
            draggedPiece.style.left = '';
            draggedPiece.style.top = '';
            draggedPiece.style.opacity = '1';

            checkDrop(touch.clientX, touch.clientY);
            draggedPiece = null;
        }

        function checkDrop(x, y) {
            // Simple collision detection with grid
            const board = document.getElementById('gridBoard');
            const rect = board.getBoundingClientRect();

            if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {
                // Snap to grid logic would go here
                // For this MVP, we'll just simulate placement success if dropped on board
                // In a full implementation, we need to calculate cell coordinates

                // Visual feedback
                draggedPiece.classList.add('placed');
                board.appendChild(draggedPiece);
                draggedPiece.style.position = 'absolute';

                // Snap to nearest cell (simplified)
                const relativeX = x - rect.left;
                const relativeY = y - rect.top;
                const col = Math.floor(relativeX / CELL_SIZE);
                const row = Math.floor(relativeY / CELL_SIZE);

                draggedPiece.style.left = (col * CELL_SIZE) + 'px';
                draggedPiece.style.top = (row * CELL_SIZE) + 'px';

                checkWinCondition();
            } else {
                // Return to container
                draggedPiece.classList.remove('placed');
                draggedPiece.style.position = '';
                document.getElementById('piecesContainer').appendChild(draggedPiece);
            }
        }

        function checkWinCondition() {
            const placedPieces = document.querySelectorAll('.grid-board .piece');
            const totalPieces = generateLevel(currentLevel).pieces.length;

            if (placedPieces.length === totalPieces) {
                // Simple win check - just checking count for MVP
                score += 100;
                document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
                saveState();

                // Celebration animation
                placedPieces.forEach(p => {
                    p.style.animation = 'pulse 0.5s ease infinite';
                });

                // Show Level Complete Modal
                setTimeout(() => {
                    GameInterface.showGameOver({
                        text: 'Level Complete!',
                        score: score,
                        level: currentLevel
                    });
                    // Override the "Play Again" button to be "Next Level"
                    const modalBtn = document.querySelector('#gameOverlay .btn-primary');
                    if (modalBtn) {
                        modalBtn.textContent = 'Next Level';
                        modalBtn.onclick = () => {
                            GameInterface.hideOverlay();
                            currentLevel++;
                            setupLevel(currentLevel);
                        };
                    }
                }, 500);
            }
        }

        function saveState() {
            localStorage.setItem('draggerState', JSON.stringify({
                level: currentLevel,
                score: score
            }));
        }

        function loadState() {
            const state = JSON.parse(localStorage.getItem('draggerState'));
            if (state) {
                currentLevel = state.level;
                score = state.score;
                document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
            }
        }

        // Initialize
        initGame();

    </script>
</body>

</html>